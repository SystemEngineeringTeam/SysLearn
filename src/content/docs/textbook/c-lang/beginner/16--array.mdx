---
title : 配列
slug: http://localhost:4321/textbook/c-lang/beginner/array
---

import { Aside } from '@astrojs/starlight/components';
import { Tabs, TabItem } from '@astrojs/starlight/components';

同じ型の変数の集まりは、ひとまとめにして表現することができます。
そのために利用する**配列**の基礎について学んでいきましょう。

## 配列とは

まずは、３人の学生の点数について、その合計値と平均値を算出するプログラムを作成してみましょう。

<Tabs>
<TabItem label="ソースコード">
```c
#include <stdio.h>

int main(int argc, const char * argv[]) {
    int score1 =  70;  // 1 人目の点数
    int score2 = 100;  // 2 人目の点数
    int score3 =  85;  // 3 人目の点数

    int sum = 0;  // 合計点（初期値：0）
    
    printf("1人目の点数: %3d\n", score1);  sum += score1;
    printf("2人目の点数: %3d\n", score2);  sum += score2;
    printf("3人目の点数: %3d\n", score3);  sum += score3;
    
    printf("合計点: %d\n", sum);
    printf("平均点: %.1f\n", (double)sum / 3);
    
    return 0;
}
```
</TabItem>
<TabItem label="実行例">
```
1人目の点数:  70
2人目の点数: 100
3人目の点数:  85
合計点: 255
平均点: 85.0
```
</TabItem>
</Tabs>

このプログラムでは、３人の点数がそれぞれ`int`型の３つの変数（`score1`・`score2`・`score3`）として表されています。

さて、今後プログラムを組んでいくうえで、学生の人数が100人に増えた場合を考えましょう。
このプログラムのようなやり方では、点数を格納するための変数を100つも用意することになるでしょう。
100もの変数を管理する必要がありますし、なにより変数の定義が大変に思われるかもしれません。

そこで利用するのが**配列**（array）になります。
**配列**は、同じ型の値の集合を１つの変数として表現することができます。
また、配列に格納されるひとつひとつの値を**要素**（element）と呼びます。

<Aside type="note" title="配列">
**配列**とは、同一型の変数（**要素**）が線型かつ連続的に並んだものである。
</Aside>

## 配列の宣言

まずは配列を宣言していきましょう。
配列の宣言では、次のように、**要素型（element type）**、**配列名**（変数名）、**要素数**を与えることで実現します。

```c
要素型 配列名[要素数];
```

例として、要素型が`int`型で要素数が`5`の配列を宣言してみます。

```c
int a[5];
```

これによって、`int`型の５つの値を格納することができる１つの変数を、配列名`a`として宣言することができました。

<Aside type="note" title="配列の宣言">
```c
要素型 配列名[要素数];
```
</Aside>

## 要素と添字

配列が持つ個々の要素への**アクセス**は、**添字演算子**（subscript operator）を用いることで実現します。
扱う配列の配列名が`a`である場合、添字演算子は`a[b]`として表されます。
これは、配列`a`の先頭から`b`個後ろの要素を意味します。

また、演算子`[]`内のオペランドは、**添字**（subscript）と呼ばれます。
これは、“先頭要素から何個後ろの要素なのか”を表す整数値になります。
そのため、要素数が`n`である配列の添字の範囲が、`0`から`n - 1`までの整数値となることに注意しましょう。

実際に、冒頭のプログラムを、配列を用いて表現してみましょう。

<Tabs>
<TabItem label="ソースコード">
```c
#include <stdio.h>

int main(int argc, const char * argv[]) {
    // 配列の宣言
    int scores[3];  // int型の 3 つの値を格納する配列
    
    // 要素へのアクセス
    scores[0] =  70;  // 1 人目の点数
    scores[1] = 100;  // 2 人目の点数
    scores[2] =  85;  // 3 人目の点数
    
    int sum = 0;  // 合計点（初期値：0）
    
    printf("1人目の点数: %3d\n", scores[0]);  sum += scores[0];
    printf("2人目の点数: %3d\n", scores[1]);  sum += scores[1];
    printf("3人目の点数: %3d\n", scores[2]);  sum += scores[2];
    
    printf("合計点: %d\n", sum);
    printf("平均点: %.1f\n", (double)sum / 3);
    
    return 0;
}
```
</TabItem>
<TabItem label="実行例">
```
1人目の点数:  70
2人目の点数: 100
3人目の点数:  85
合計点: 255
平均点: 85.0
```
</TabItem>
</Tabs>

<Aside type="note" title="配列の要素へのアクセス">
要素数`n`の配列`a`の要素は、`a[0]`、`a[1]`、`a[2]`、……、`a[n - 1]`としてアクセスできる。
</Aside>

## 配列の初期化

配列の各要素の値の設定を、代入ではなく初期化によって実現してみましょう。
配列の初期化子は、各要素に対する初期化子をコンマ（`,`）で区切って順に並べたものを`{}`で囲んだ形式で与えます。

まずは、冒頭のプログラムを、配列の初期化を用いて表現してみましょう。

<Tabs>
<TabItem label="ソースコード">
```c
#include <stdio.h>

int main(int argc, const char * argv[]) {
    int scores[3] = {70, 100, 85};  // 配列の初期化
    
    int sum = 0;  // 合計点（初期値：0）
    
    printf("1人目の点数: %3d\n", scores[0]);  sum += scores[0];
    printf("2人目の点数: %3d\n", scores[1]);  sum += scores[1];
    printf("3人目の点数: %3d\n", scores[2]);  sum += scores[2];
    
    printf("合計点: %d\n", sum);
    printf("平均点: %.1f\n", (double)sum / 3);
    
    return 0;
}
```
</TabItem>
<TabItem label="実行例">
```
1人目の点数:  70
2人目の点数: 100
3人目の点数:  85
合計点: 255
平均点: 85.0
```
</TabItem>
</Tabs>

配列の宣言と各要素への代入を1行で表現することができました。

また、配列に与える初期化子の規則を確認していきましょう。

配列に与える初期化子内の、最後の初期化子の後ろのコンマ（`,`）は省略可能です。
最後の初期化子の後ろにコンマを記述する形式には、初期化の追加や削除にともなって、コンマを記述したり削除したりしなくてよくなるというメリットがあります。

```c
int a[3] = {
    1,
    2,
    3,  // 最後の初期化子の後ろのコンマ（,）は省略可能
};
/**
 * a[0]: 1
 * a[1]: 2
 * a[2]: 3
 */
 ```

次の配列`b`のような、要素数を指定しない場合は、`{}`内の初期化子の個数に基づいて、配列の要素数が自動的に決定されます。

```c
int b[] = {1, 2, 3};  // 要素数は自動的に 3 になる
/**
 * b[0]: 1
 * b[1]: 2
 * b[2]: 3
 */
```

次の配列`c`を確認すると、`{}`内に初期化子が与えられていない要素は、`0`で初期化されることがわかります。

```c
int c[3] = {1, 2};  // int c[] = {1, 2, 0}; と同じ
/**
 * c[0]: 1
 * c[1]: 2
 * c[2]: 0
 */
```

次の配列`d`の場合では、`d[0]`が`0`で初期化され、つづく`d[1]`、`d[2]`は初期化子が与えられないため`0`で初期化されています。

```c
int d[3] = {0};  // 全要素を 0 で初期化
/**
 * d[0]: 0
 * d[1]: 0
 * d[2]: 0
 */
```

<Aside type="note" title="初期化をともなう配列の宣言">
```c
要素型 配列名[要素数] = {要素, 要素, 要素,};
// 要素数および最後の初期化子の後ろのコンマ（,）は省略可能
```
</Aside>

## 配列の走査

**走査**（traverse）とは、配列の要素をひとつずつ順番になぞっていくことを意味します。
`for`文を用いた配列の走査について確認しましょう。

配列を先頭から順に走査するには、`for`文のカウンタ用変数を、配列の添字として利用することで実現できます。
冒頭のプログラムを、配列と`for`文を用いて表現してみましょう。

<Tabs>
<TabItem label="ソースコード">
```c
#include <stdio.h>

int main(int argc, const char * argv[]) {
    int scores[3] = {70, 100, 85};  // 配列の初期化
    
    int sum = 0;  // 合計点（初期値：0）
    
    // 配列の走査
    for (int i = 0; i < 3; i++) {
        printf("%d人目の点数: %3d\n", i + 1, scores[i]);
        sum += scores[i];
    }
    
    printf("合計点: %d\n", sum);
    printf("平均点: %.1f\n", (double)sum / 3);
    
    return 0;
}
```
</TabItem>
<TabItem label="実行例">
```
1人目の点数:  70
2人目の点数: 100
3人目の点数:  85
合計点: 255
平均点: 85.0
```
</TabItem>
</Tabs>

`for`文を用いることで、添字のみが異なるような命令を、一括で記述することができました。
命令や繰返し処理を工夫することで、さまざまなプログラムに応用することができます。

さて、実際に練習問題を解きながら、配列を学んでいきましょう。

## 練習問題

<Tabs>
<TabItem label="問題">
キーボードからの入力により、５人の身長（`double`型）を配列`heights`に格納してください。
また、閾値`th = 170.0`を超える値の一覧を出力してください。
また、最大値と最小値を求めて出力してください。
</TabItem>
<TabItem label="実行例">
```
heights[0]? 170.0（注：標準入力）
heights[1]? 168.2（注：標準入力）
heights[2]? 186.9（注：標準入力）
heights[3]? 152.0（注：標準入力）
heights[4]? 170.5（注：標準入力）
---------------
# heights>170.0
heights[2]: 186.9
heights[4]: 170.5
---------------
max: 186.9
min: 152.0
```
</TabItem>
<TabItem label="ヒント１">
配列の要素への標準入力は、変数の標準入力と同様のやり方で実現できます。
繰返し処理を活用することで、すべての要素へアクセスしてみましょう。

```c
scanf("%lf", &heights[i]);
```
</TabItem>
<TabItem label="ヒント２">
繰返し処理のなかで、条件に合致する要素のみを標準出力してみましょう。
標準入力用の繰返し構文とは別の繰返し構文を用意する必要があります。

```c
// 配列の要素が閾値を超える場合
if (heights[i] > th) printf("heights[%d]: %.1f\n", i, heights[i]);
```
</TabItem>
<TabItem label="ヒント３">
最大値を求めるには、次のようなやり方があります。

- 配列内の適当な要素を持つ変数`max`を用意する
- 配列を走査するなかで、`max`を超える値がみつかった場合、その値を`max`に代入することで更新する

```c
// 適当な要素の値を設定しておく
double max = heights[0];

for (int i = 0; i < 5; i++) {
    // 最大値の更新
    if (max < heights[i]) max = heights[i];
}
```
</TabItem>
<TabItem label="解答例">
```c
#include <stdio.h>

int main(int argc, const char * argv[]) {
    double heights[5];
    double th = 170.0;
    
    // 整数値の入力
    for (int i = 0; i < 5; i++) {
        printf("heights[%d]? ", i);
        scanf("%lf", &heights[i]);
    }
    
    // 最大値および最小値の宣言（適当な要素の値で初期化しておく）
    double max, min;
    max = min = heights[0];
    
    puts("---------------");
    
    printf("# heights>%.1f\n", th);
    
    for (int i = 0; i < 5; i++) {
        // 閾値を超える身長の出力
        if (heights[i] > th) printf("heights[%d]: %.1f\n", i, heights[i]);
        
        // 最大値および最小値の更新
        if (max < heights[i]) max = heights[i];
        if (min > heights[i]) min = heights[i];
    }
    
    puts("---------------");
    
    printf("max: %.1f\n", max);
    printf("min: %.1f\n", min);
    
    return 0;
}
```
</TabItem>
</Tabs>

## 確認クイズ


