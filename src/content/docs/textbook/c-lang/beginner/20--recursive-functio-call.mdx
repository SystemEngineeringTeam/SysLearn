---
title : ex. 再帰関数呼出し
slug: http://localhost:4321/textbook/c-lang/beginner/recursive-functio-call
---

import { Aside } from '@astrojs/starlight/components';
import { Tabs, TabItem } from '@astrojs/starlight/components';

関数は、その関数内で自身と同じ関数を呼び出すことができます。
この呼出しは再帰関数呼出しと呼ばれ、プログラムの簡略化に役立ちます。
再帰関数呼出しの基本を学んでいきましょう。

## 再帰

自分自身を含んでいたり、自分自身によって定義されたりする事象は、**再帰的**（recursive）であるといえます。

再帰的な現象の一例として、合わせ鏡があります。
合わせ鏡では、鏡に映る鏡の中に鏡が映り、さらにその中の鏡にもまた鏡が映る……、といった具合に果てしなく続いていきます。

再帰の考え方を効率的に活用することで、繰返し処理のともなうプログラムを簡潔かつ効率的に記述することができます。

## 関数の再帰的定義

再帰を扱う例として、階乗値を求める関数を作成してみましょう。

まずは、非負の整数`n`の階乗を、再帰的に定義してみます。

- 階乗`n!`の定義（`n`は非負の整数であるとする）
    - `0! = 1`
    - `n > 0`ならば、`n! = n * (n - 1)!`

たとえば、`3`の階乗は`3 * 2!`で表され、この計算式の過程に使われる式`2!`は`2 * 1!`で表されます。
したがって、`3! = 3 * 2! = 3 * (2 * 1!) = 3 * 2 * (1 * 0!)`となります。
ここで、`0!`の定義`0! = 1`より、`3!`は最終的に`3! = 3 * 2 * 1 * 1 = 6`として算出されることになります。

この定義を実現したものが、次のプログラムになります。

<Tabs>
<TabItem label="ソースコード">
```c
#include <stdio.h>

int factorial(int n) {
    if (n > 0)
        return n * factorial(n - 1);
    else
        return 1;
}

int main(int argc, const char * argv[]) {
    int n = 3;
    
    printf("%d! = %d\n", n, factorial(n));
    
    return 0;
}
```
</TabItem>
<TabItem label="実行例">
```
3! = 6
```
</TabItem>
</Tabs>

このプログラムは、次の手順によって実行されていきます。

1. 関数呼出し式`factorial(3)`によって、関数`factorial`を呼び出します。
この関数は、仮引数`n`に`3`を受け取ることで、返却値`3 * factorial(2)`を返します。
この乗算を行うためには、`factorial(2)`の値が必要になるため、実引数`2`を渡して関数`factorial`を呼び出します。

2. 呼び出された関数`factorial`は、仮引数`n`に`2`を受け取ります。
この関数の返却値`2 * factorial(1)`の乗算を行うために、実引数`1`を渡して関数`factorial`を呼び出します。

3. 呼び出された関数`factorial`は、仮引数`n`に`1`を受け取ります。
この関数の返却値`1 * factorial(0)`の乗算を行うために、実引数`0`を渡して関数`factorial`を呼び出します。

4. 呼び出された関数`factorial`は、仮引数`n`に`0`を受け取ります。
そのため、返却値として`1`を返します。
なお、この時点で初めて`return`文が実行されます。

5. 返却値`1`を受け取った関数`factorial`は、`1 * factorial(0)`すなわち`1 * 1`を返却値として返します。

6. 返却値`1`を受け取った関数`factorial`は、`2 * factorial(1)`すなわち`2 * 1`を返却値として返します。

7. 返却値`2`を受け取った関数`factorial`は、`3 * factorial(2)`すなわち`3 * 2`を返却値として返します。

この手順によって、`3`の階乗値`6`を得ることができます。

このような関数の再帰的な呼び出しを、**再帰関数呼出し**（recursive functio call）と呼びます。

## 練習問題

<Tabs>
<TabItem label="問題">
異なる`n`個の整数から、`r`個の整数を取り出す組合わせの数`C(n, r)`を求める関数を作成してください。

```c
int combination(int n, int r) {
    // TODO
}

int main(int argc, const char * argv[]) {
    int n = ***, r = ***;
    
    printf("C(%d, %d) = %d\n", n, r, combination(n, r));
    
    return 0;
}
```

なお、`C(n, r)`は次のように定義されます。

`C(n, r) = C(n - 1, r - 1) + C(n - 1, r)`（ただし、`C(n, 0) = C(n, n) = 1`、`C(n, 1) = n`）
</TabItem>
<TabItem label="実行例">
```
C(6, 3) = 20
```
```
C(6, 1) = 6
```
```
C(6, 0) = 1
```
</TabItem>
<TabItem label="ヒント１">
`C(n, r)`の定義より、基本的には`C(n - 1, r - 1) + C(n - 1, r)`を返却しましょう。

```c
return combination(n - 1, r - 1) + combination(n - 1, r);
```
</TabItem>
<TabItem label="ヒント２">
`C(n, 0)`および`C(n, n)`の定義から、`r = 0`または`r = n`の場合は、`1`を返却しましょう。

```c
if (r == 0 || r == n)
    return 1;
```
</TabItem>
<TabItem label="ヒント３">
`C(n, 1)`の定義から、`r = 1`の場合は、`n`を返却しましょう。

```c
if (r == 1)
    return n;
```
</TabItem>
<TabItem label="解答例">
```c
int combination(int n, int r) {
    if (r == 0 || r == n)
        return 1;  // C(n, 0) = C(n, n) = 1
    else if (r == 1)
        return n;  // C(n, 1) = n
    else
        return combination(n - 1, r - 1) + combination(n - 1, r);
}

int main(int argc, const char * argv[]) {
    int n = 6, r = 3;
    
    printf("C(%d, %d) = %d\n", n, r, combination(n, r));
    
    return 0;
}
```
</TabItem>
</Tabs>
